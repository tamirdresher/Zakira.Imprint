---
layout: default
title: Package Patterns
parent: Concepts
nav_order: 4
description: "Skills-only vs code+skills package patterns."
permalink: /concepts/package-patterns
---

# Package Patterns
{: .fs-9 }

Two patterns for creating Imprint packages: skills-only and code+skills.
{: .fs-6 .fw-300 }

---

## Overview

Imprint supports two distinct package patterns:

| Pattern | Ships DLL? | Development Dependency? | Use Case |
|:--------|:-----------|:------------------------|:---------|
| Skills-Only | No | Yes | Standards, guidelines, best practices |
| Code + Skills | Yes | No | Libraries with AI guidance |

---

## Pattern 1: Skills-Only Packages

Skills-only packages contain just AI skills and MCP fragments - no compiled code. They're marked as development dependencies, meaning they don't add any runtime cost to consumer applications.

### When to Use

- Organization coding standards
- Security best practices
- Framework guidelines
- Domain-specific knowledge
- Project templates/patterns

### Project Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
    
    <!-- Don't ship any DLL -->
    <IncludeBuildOutput>false</IncludeBuildOutput>
    
    <!-- Mark as build-time only -->
    <DevelopmentDependency>true</DevelopmentDependency>
    
    <!-- Skip unnecessary analysis -->
    <NoPackageAnalysis>true</NoPackageAnalysis>
    
    <!-- Important: Include SDK dependency in package -->
    <SuppressDependenciesWhenPacking>false</SuppressDependenciesWhenPacking>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Zakira.Imprint.Sdk" Version="1.0.0-preview">
      <PrivateAssets>compile</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <Imprint Include="skills\**\*" />
    <Imprint Include="mcp\*.mcp.json" Type="Mcp" />
  </ItemGroup>
</Project>
```

### Key Properties Explained

| Property | Value | Purpose |
|:---------|:------|:--------|
| `IncludeBuildOutput` | `false` | No DLL in the package |
| `DevelopmentDependency` | `true` | NuGet marks as build-time only |
| `NoPackageAnalysis` | `true` | Skip unnecessary package validation |
| `SuppressDependenciesWhenPacking` | `false` | Include SDK dependency in `.nuspec` |

### Package Contents

A skills-only package looks like this:

```
MyOrg.Skills.1.0.0.nupkg
├── build/
│   └── MyOrg.Skills.targets       # Auto-generated by SDK
├── skills/
│   ├── coding-standards/
│   │   └── SKILL.md
│   └── security/
│       └── SKILL.md
└── mcp/
    └── MyOrg.Skills.mcp.json
```

### Consumer Experience

When a consumer installs this package:

1. No runtime dependency is added
2. Skills are copied on build
3. MCP servers are merged on build
4. Clean removes everything

```xml
<!-- Consumer's project -->
<PackageReference Include="MyOrg.Skills" Version="1.0.0" />
<!-- No runtime reference appears in the compiled output -->
```

---

## Pattern 2: Code + Skills Packages

Code + skills packages ship both a compiled library AND AI skills. When developers install your library, they get both the code and guidance on how to use it.

### When to Use

- SDK or library distribution
- Frameworks with best practices
- APIs with usage guidance
- Tools with operational knowledge

### Project Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    
    <!-- Normal library settings -->
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <PackageId>MyOrg.Utils</PackageId>
    <Version>1.0.0</Version>
    
    <!-- Don't set IncludeBuildOutput=false - we want the DLL -->
    <!-- Don't set DevelopmentDependency - consumers need runtime code -->
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Zakira.Imprint.Sdk" Version="1.0.0-preview">
      <PrivateAssets>compile</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <Imprint Include="skills\**\*" />
    <Imprint Include="mcp\*.mcp.json" Type="Mcp" />
  </ItemGroup>
</Project>
```

### Key Differences from Skills-Only

| Property | Skills-Only | Code + Skills |
|:---------|:------------|:--------------|
| `IncludeBuildOutput` | `false` | `true` (default) |
| `DevelopmentDependency` | `true` | Not set (false) |
| `TargetFramework` | `netstandard2.0` | Actual target (e.g., `net8.0`) |

### Package Contents

A code + skills package looks like this:

```
MyOrg.Utils.1.0.0.nupkg
├── lib/
│   └── net8.0/
│       ├── MyOrg.Utils.dll
│       └── MyOrg.Utils.xml
├── build/
│   └── MyOrg.Utils.targets       # Auto-generated by SDK
├── skills/
│   └── string-utils/
│       └── SKILL.md
└── mcp/
    └── MyOrg.Utils.mcp.json
```

### Consumer Experience

When a consumer installs this package:

1. Runtime reference is added
2. DLL is used during compilation and at runtime
3. Skills are copied on build
4. MCP servers are merged on build

```xml
<!-- Consumer's project -->
<PackageReference Include="MyOrg.Utils" Version="1.0.0" />
```

```csharp
// Consumer can use the code
using MyOrg.Utils;

var slug = "Hello World".Slugify();
```

---

## Choosing the Right Pattern

### Use Skills-Only When:

- You're distributing pure guidance (no code)
- You want zero runtime footprint
- You're packaging organizational standards
- The skills apply across different projects/technologies

### Use Code + Skills When:

- You're shipping a library with usage guidance
- The skills specifically teach how to use your code
- Users need both runtime code and AI assistance
- The skills reference your library's APIs

---

## Hybrid Approach

For complex scenarios, you can create separate packages:

```
MyOrg.Utils/
├── MyOrg.Utils.csproj          # Code-only library
└── MyOrg.Utils.Skills.csproj   # Skills-only package
```

This allows:
- Library updates independent of skill updates
- Optional skill installation
- Different versioning strategies

```xml
<!-- Consumer chooses what to install -->
<PackageReference Include="MyOrg.Utils" Version="1.0.0" />
<PackageReference Include="MyOrg.Utils.Skills" Version="1.0.0" /> <!-- Optional -->
```

---

## Example: Complete Code + Skills Package

Here's a complete example of a string utilities library with AI skills:

**StringUtils.csproj:**
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Zakira.Imprint.Sdk" Version="1.0.0-preview">
      <PrivateAssets>compile</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <Imprint Include="skills\**\*" />
  </ItemGroup>
</Project>
```

**StringExtensions.cs:**
```csharp
namespace StringUtils;

public static class StringExtensions
{
    public static string Slugify(this string text)
    {
        // Implementation
    }
    
    public static string Truncate(this string text, int maxLength)
    {
        // Implementation
    }
}
```

**skills/string-utils/SKILL.md:**
```markdown
# StringUtils Library

This project uses the StringUtils library. When working with strings:

## Available Extensions

- `Slugify()` - Convert text to URL-friendly slugs
- `Truncate(maxLength)` - Truncate with ellipsis

## Examples

```csharp
// Creating slugs for URLs
var slug = title.Slugify();

// Truncating for display
var preview = content.Truncate(100);
```

## Best Practices

- Always use `Slugify()` for URL generation
- Use `Truncate()` instead of manual substring operations
```

---

## Next Steps

- [Creating Skill Packages]({{ site.baseurl }}/guides/creating-skill-packages) - Detailed guide for skills-only
- [Creating Code+Skills Packages]({{ site.baseurl }}/guides/creating-code-skill-packages) - Detailed guide for hybrid
- [Configuration Reference]({{ site.baseurl }}/reference/configuration) - All package options
